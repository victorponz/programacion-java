---
typora-copy-images-to: ../assets/img/poo-tablas/
typora-root-url: ../../
layout: post
title: JPA con Spring Boot
categories: bd
conToc: true
permalink: jpa-con-spring-boot
---

En este apartado vamos a ver el funcionamiento de la parte [ORM](https://en.wikipedia.org/wiki/Object%E2%80%93relational_mapping) del framework llamado [Spring Boot](https://spring.io/)

Un ORM facilita el trabajo de creaci√≥n de aplicaciones de base de datos ya que pr√°cticamente automatiza la persistencia y consulta de datos bas√°ndose para ello en el mapeo de las entidades en objetos y viceversa.

## Esqueleto

El primer paso es descargar el esqueleto de proyecto desde [aqu√≠](/programacion-java/assets/jpa.zip). En el archivo `pom.xml` est√°n definidas las siguientes dependencias:

* `spring-boot-starter-data-jpa` define  que utilizamos la capa JPA de Spring (Java Persistent API)
* `sqlite-jdbc` define la base de datos SQLite
* `hibernate-community-dialects` se define que vamos a usar dialectos JDBC

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		 xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
	<modelVersion>4.0.0</modelVersion>
	<parent>
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-starter-parent</artifactId>
		<version>3.0.5</version>
		<relativePath/> <!-- lookup parent from repository -->
	</parent>
	<groupId>org.ieselcaminas</groupId>
	<artifactId>jpa</artifactId>
	<version>0.0.1-SNAPSHOT</version>
	<name>jpa</name>
	<description>Proyecto demo para JPA</description>
	<properties>
		<java.version>17</java.version>
	</properties>
	<dependencies>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-data-jpa</artifactId>
		</dependency>
		<!-- https://mvnrepository.com/artifact/org.xerial/sqlite-jdbc -->
        <dependency>
            <groupId>org.xerial</groupId>
            <artifactId>sqlite-jdbc</artifactId>
            <version>3.45.1.0</version>
        </dependency>
		<!-- https://mvnrepository.com/artifact/org.hibernate.orm/hibernate-community-dialects -->
		<dependency>
			<groupId>org.hibernate.orm</groupId>
			<artifactId>hibernate-community-dialects</artifactId>
		</dependency>
	</dependencies>

	<build>
		<plugins>
			<plugin>
				<groupId>org.springframework.boot</groupId>
				<artifactId>spring-boot-maven-plugin</artifactId>
			</plugin>
		</plugins>
	</build>

</project>
```

La clase java que tiene el m√©todo `main` es `JpaApplication.java`

![image-20230419094909718](/programacion-java/assets/img/poo-tablas/image-20230419094909718.png)

Que contiene el siguiente c√≥digo. Es com√∫n para todas las aplicaciones

```java
package org.ieselcaminas.jpa;

import org.springframework.boot.CommandLineRunner;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class JpaApplication implements CommandLineRunner {

	public static void main(String[] args) {
		SpringApplication.run(JpaApplication.class, args);
	}
	//En este m√©todo definimos nuestro propio c√≥digo
	@Override
	public void run(String... args) {
		
	}
}
```

`SpringApplication.run(JpaApplication.class, args);` es quien inicia la aplicaci√≥n `SpringBoot`

## Propiedades

Debemos definir un archivo llamado `application.properties` dentro de la carpeta `resources` con el siguiente contenido:

```properties
spring.datasource.url=jdbc:sqlite:customers.sqlite // Importante. Se guarda en ra√≠z del proyecto
spring.jpa.database-platform=org.hibernate.community.dialect.SQLiteDialect
spring.jpa.hibernate.ddl-auto=validate
```

* `spring.datasource.url=jdbc:sqlite:jdbc:sqlite:customers.sqlite` define como base de datos `customers.sqlite` dentro del directorio ra√≠z.
* `spring.jpa.database-platform=org.hibernate.community.dialect.SQLiteDialect` y aqu√≠ se define que, de todos los dialectos SQL propietarios o no, se va a usar `org.hibernate.community.dialect.SQLiteDialect`
* `spring.jpa.hibernate.ddl-auto=validate` Cuando la aplicaci√≥n arranca, se comprueba si las entidades definidas coinciden con la las tablas de la base de datos. Si no es as√≠, la aplicaci√≥n no arranca hasta que se arregle.



## Estructura de una aplicaci√≥n de base de datos

Una aplicaci√≥n web bien estructurada se divide en capas, cada una con responsabilidades claras:

```
Controller  ‚Üí  Service  ‚Üí  Repository  ‚Üí  Base de datos
```

* **Controller (Controlador)**

  - Recibe **peticiones HTTP** (GET, POST, etc.) del usuario o del frontend.

  - No contiene l√≥gica de negocio complicada.

  - Llama al **Service** para realizar la acci√≥n.

* **Service (Servicio)**

  - Contiene la **l√≥gica de negocio** (reglas, validaciones, transacciones).

  - Decide c√≥mo se usan los datos, qu√© crear, qu√© actualizar, etc.

  - Llama a los **Repository** para acceder a la base de datos.

* **Repository (Repositorio)**

  - Interact√∫a con la base de datos usando JPA/Hibernate.

  - Solo hace consultas, inserciones, borrados.

* **Entity (Entidad)**

  * Clase que *mapea* los registros de las tablas de la base de datos en objetos java y viceversa

## Base de datos

Creamos la base de datos SQLite y creamos la siguiente tabla:

```sql
CREATE TABLE customer (
	id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
	first_name TEXT NOT NULL,
	last_name TEXT NOT NULL
);
```

## Entidad

Primero hemos de definir las entidades como clases POJO (son colo las vistas en el modelo entidad-relaci√≥n).

> -warning-Es necesario que las columnas de la base de datos tengan el mismo nombre que los atributos de la clase. Antes de cada camelCase se introduce un  `_` y se pone en min√∫scula `camel_case`

> -info-
>
> Pod√©is instalar el plugin JPA Buddy, que nos facilita la creaci√≥n de las clases POJO
> ![image-20260213082810591](/programacion-java/assets/img/poo-tablas/image-20260213082810591.png)

```java
package org.ieselcaminas.jpa.entity;

import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;

@Entity
public class Customer {

  @Id
  @GeneratedValue(strategy=GenerationType.IDENTITY)
  private Long id;
  private String firstName;
  private String lastName;

  protected Customer() {}
  public Customer(String firstName, String lastName) {
    this.firstName = firstName;
    this.lastName = lastName;
  }
  public Long getId() {
    return id;
  }
  public String getFirstName() {
    return firstName;
  }
  public void setFirstName(String firstName) {
    this.firstName = firstName;
  }
  public String getLastName() {
    return lastName;
  }

  public void setLastName(String lastName) {
    this.lastName = lastName;
  }

  @Override	
  public String toString() {
      return id + " - " + firstName + " - " + lastName;
  }

}
```

Vemos que esta clase se anota con `@Entity` para indicarle al framework que esta clase la debe tratar como una entidad que tiene persistencia en base de datos. 

```java
@Id
@GeneratedValue(strategy=GenerationType.IDENTITY)
private Long id;
```

Estas anotaciones le indican a JPA que el atributo `id` es la clave primaria y que el valor se genera autom√°ticamente. Despu√©s cada atributo de la entidad se mapea en un campo en la base de datos.

## Repositorio

El siguiente paso es crear `CustomerRepository`:

```java
package org.ieselcaminas.jpa.repository;

import org.ieselcaminas.jpa.entity.Customer;
import org.springframework.data.repository.CrudRepository;

public interface CustomerRepository extends CrudRepository<Customer, Long> {

}
```

Extiende `CrudRepository` para poder realizar las operaciones [CRUD](https://en.wikipedia.org/wiki/Create,_read,_update_and_delete) `<Customer, Long>`. `Long` es el tipo de la clave primaria de la entidad `Customer`.

De momento no nos hace falta definir m√©todos de acceso a datos porque `CrudRepository`  ya provee `findById` que selecciona un elemento a partir su `id` y `findAll` que devuelve una lista de todos los elementos.

Vamos a probar el repositorio creando algunos `Customer`. Primero hemos de crear un constructor para que Spring cree la clase `customerRepository` por nosotros. Esto se denomina  [Dependency Injection](https://en.wikipedia.org/wiki/Dependency_injection)

```java
private final CustomerRepository customerRepository;

public JpaApplication(CustomerRepository customerRepository){
    this.customerRepository = customerRepository;
}
```

Este repositorio permite realizar las operaciones CRUD, as√≠ como muchas operaciones de consulta predefinidas.



![image-20260213083554271](/programacion-java/assets/img/poo-tablas/image-20260213083554271.png)

Y ahora ya podemos crear alg√∫n `Customer` y mostrar todos:

```java
@Override
@Transactional // IMPORTANTE - Para no dar errores de sesiones.
public void run(String... args) {
    Customer c = new Customer("Pepe", "Garc√≠a");
    //El repositorio es donde est√°n todos los m√©todos que tratan con la base de datos.
    //En este caso est√° haciendo un INSERT ya que el objeto es nuevo
    this.customerRepository.save(c);
    
    //Pero tambi√©n puedo modificar un registro
    c.setFirstName("Juan");
	this.customerRepository.save(c);
    
    //Vamos a seleccionar el Customer con id 1
    //Se escribe 1L porque es un dato escrito a mano de tipo long
    Optional<Customer> clienteOp = this.customerRepository.findById(1L);
    clienteOp.ifPresent(System.out::println);
    
    //Si queremos acceder al objeto Customer
    if (clienteOp.isPresent()){
        c = clienteOp.get();
        System.out.println(c);
    }

    //El m√©todo findAll devuelve todos los registros de la entidad asociada
    this.customerRepository.findAll().forEach(System.out::println);

    //En este c√≥digo estamos guardando los datos en un Iterable que es lo que devuelven los m√©todos findAll
    Iterable<Customer> l = this.customerRepository.findAll();
    for (Customer customer : l) {
        System.out.println(customer);
    }
    
    //Cuidado que si no existe el registro con ID 5, saltar√° una excepci√≥n
    try {
        c = this.customerRepository.findById(5L).get();
        this.customerRepository.delete(c);
        System.out.println(c);
    } catch (NoSuchElementException e) {
        System.out.println(" No existe el elemento con ID 5");
    }
    
    // Vamos a hacer una b√∫squeda por FirstName que  nos devuelva un lista de clientes que tengan ese apellido
    clientes = this.customerRepository.findCustomerByFirstName("Pepe");
    clientes.forEach(System.out::println);
    // Que nos devuelve s√≥lo uno
	c = this.customerRepository.findFirstCustomerByFirstName("Pepe");
	/**
		Tambi√©n se puede usar findOneCustomerByFirstName, pero si hay m√°s de un usuario, saltar√° una excepci√≥n
	*/
}
```

> -alert-
>
> Tal vez os aparezca `findCustomerByFirstName` en rojo. Si es as√≠, con el bot√≥n secundario del rat√≥n, seleccionad la opci√≥n`Show Context Actions`
>
> 
>
> ![image-20260213085733671](/programacion-java/assets/img/poo-tablas/image-20260213085733671.png)
>
> Ahora seleccionad la opci√≥n `Create repository method 'findCustomerByFirstName' in 'CustomerRepository'`
>
> ![image-20260213085516707](/programacion-java/assets/img/poo-tablas/image-20260213085516707.png)

Esto os debe haber creado el m√©todo en el repositorio:

```java
package org.ieselcaminas.jpa.repository;

import org.ieselcaminas.jpa.entity.Customer;
import org.springframework.data.repository.CrudRepository;

import java.util.List;

public interface CustomerRepository extends CrudRepository<Customer, Long> {
	// Como es una interface, s√≥lo se especifica la signatura
    List<Customer> findCustomerByFirstName(String firstName);
}
```

### Construcci√≥n de Consultas

En el repositorio se definen todas aquellas consultas que sean necesarias. Hay algunas consultas que  ya est√°n hechas. Las puedes ver en `org.springframework.data.repository.CrudRepository`. 

En general, no hace falta escribir el cuerpo de las consultas SQL ya que lo hace Spring Boot autom√°ticamente por nosotros a partir del nombre del m√©todo y los par√°metros. Por ejemplo:

```java
// En CustomerRepository
public List<Customer> findCustomersByFirstName(String firstName);
public Customer findCustomerByFirstNameAndLastName(String firstName, String lastName)
```

Si creamos el m√©todo `findCustomersByFirstName(String firstName)` devolver√≠a aquellos con dicho `firstName` y `findCustomerByFirstNameAndLastName` que coincida el `firstName` y el `lastName`. 

> -info-Fijaos en la diferencia:
>
> * Si empieza por `findCustomerBy` devuelve un √∫nico `Customer`
> * Si  empieza por `findCustomersBy` (con `s`) devuelve una lista de `Customer`

Tienes el listado completo de Querys [aqu√≠](https://docs.spring.io/spring-data/jpa/reference/jpa/query-methods.html).

Si la consulta que queremos hacer no se puede crear con el asistente, siempre se puede escribir a mano el SQL de la misma.

```java
@Query("SELECT COUNT(c) FROM Customer c")
public int countAllRecords();
```

## Notes

Vamos a implementar la funcionalidad de poder crear notas que se adjuntan a un cliente. Es decir, vamos a crear una relaci√≥n `1:N`

Primero creamos la tabla `note`:

```sql
CREATE TABLE note (
	id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
	"text" TEXT NOT NULL,
	id_customer INTEGER,
	CONSTRAINT note_customer_FK FOREIGN KEY (id_customer) REFERENCES customer(id)
);
```

Ahora  creamos la entidad `Note`:

```java
package org.ieselcaminas.jpa;

import jakarta.persistence.*;

@Entity
public class Note {

    @Id
    @GeneratedValue(strategy=GenerationType.IDENTITY)
    private Long id;
    private String text;
    
    @ManyToOne(fetch = FetchType.EAGER)
    @JoinColumn(name="id_customer")
    private Customer customer;

    protected Note() {}
    
    public Note(String text, Customer customer) {
        this.text = text;
        this.customer = customer;
    }
    
    public Long getId() {
        return id;
    }
    public String getText() {
        return text;
    }

    public Customer getCustomer() {
        return customer;
    }

    @Override
    public String toString() {
        return text;
    }

}
```

Mediante ...

```java
@ManyToOne(fetch = FetchType.EAGER)
@JoinColumn(name="customer_id")
private Customer customer;
```

.. estamos creando un relaci√≥n `N:1`, la columna se llamar√° `customer_id` y la entidad relacionada es `Customer`

Y ahora vamos a ver la parte `1`, es decir, `Customer`

```java
@OneToMany(mappedBy = "customer",  fetch=FetchType.EAGER)
private List<Note> notes = new ArrayList<>;
```

En este caso le indicamos `mappedBy = "customer"` donde `customer` es el nombre del campo en la relaci√≥n `N`

Ahora creamos los setters.

```java
public List<Note> getNotes(){
    return this.notes;
}

public void addNote(Note note){
    this.notes.add(note);
}
```

Y generamos el repositorio para `Note`

```java
package org.ieselcaminas.jpa.repository;

import org.ieselcaminas.jpa.entity.Note;
import org.springframework.data.repository.CrudRepository;

public interface NoteRepository extends CrudRepository<Note, Long> {

}
```

Y lo inyectamos en el constructor:

```java
private final NoteRepository noteRepository;
public JpaApplication(CustomerRepository customerRepository, NoteRepository noteRepository){
	this.customerRepository = customerRepository;
	this.noteRepository = noteRepository;
}
```

Y ya podemos crear y consultar notas:

```java
@Override
// Nos evitamos conflictos al trabajar en una √∫nica transacci√≥n
@Transactional
public void run(String... args) {
    //Creamos una nota
    // 1¬∫ el cliente
    Customer c = customerRepository.findById(1L).get();
    // Y ahora la nota
    Note n = new Note("Primera nota", c);
    noteRepository.save(n);

    Customer c2 = customerRepository.findById(2L).get();
    n = new Note("Primera nota Mar√≠a", c2);
    noteRepository.save(n);

    customerRepository.findCustomersByFirstName("Pepe").forEach(System.out::println);
}
```

## Servicios

Un Service es una clase que:

* Recibe peticiones del Controller

* Aplica l√≥gica (validaciones, reglas, c√°lculos‚Ä¶)

* Usa los Repository para acceder a la base de datos

* Devuelve el resultado

üëâ Es el punto intermedio entre la web (o interfaz de comandos, o interfaz gr√°fica) y la base de datos.

```java
package org.ieselcaminas.jpa.service;

import org.ieselcaminas.jpa.entity.Customer;
import org.ieselcaminas.jpa.entity.Note;
import org.ieselcaminas.jpa.repository.CustomerRepository;
import org.ieselcaminas.jpa.repository.NoteRepository;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import java.util.List;
import java.util.Optional;

@Service
@Transactional
public class CustomerService {

    private final CustomerRepository customerRepository;
    private final NoteRepository noteRepository;

    public CustomerService(CustomerRepository customerRepository,
                           NoteRepository noteRepository) {
        this.customerRepository = customerRepository;
        this.noteRepository = noteRepository;
    }

    // Crear cliente
    public Customer createCustomer(String firstName, String lastName) {
        return customerRepository.save(new Customer(firstName, lastName));
    }

    // A√±adir nota a un cliente
    public Note addNote(Long customerId, String content) {
        Optional<Customer> customer = customerRepository.findById(customerId); // clave
        Customer c = customer.orElseThrow();
        return new Note(content, c);

    }

    // Obtener notas de un cliente
    public List<Note> getNotes(Long customerId) {
        return noteRepository.getNotesByCustomerId(customerId);
    }


    // Obtener cliente
    public Customer getCustomer(Long id) {
        return customerRepository.findById(id).orElseThrow();
    }
}

```



## Controladores

Adem√°s de los repositorios, es com√∫n crearse un controlador que haga de intermediario entre la base de datos y la entidad.

En el siguiente ejemplo tenemos un m√©todo en el controlador de `Customer` que permite la creaci√≥n de un `Customer` desde la entrada est√°ndar.

```java
package org.ieselcaminas.jpa.controller;

import org.ieselcaminas.jpa.entity.Customer;
import org.ieselcaminas.jpa.repository.CustomerRepository;
import org.ieselcaminas.jpa.service.CustomerService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;
import java.util.Scanner;

/**
 En una aplicaci√≥n, el controlador es quien gu√≠a las peticiones del cliente al m√©todo apropiado.
 A continuaci√≥n se muestra un ejemplo de controlador web
 @RestController
 @RequestMapping("/notes")
 public class NoteController {

     private final NoteService noteService;

     public NoteController(NoteService noteService) {
        this.noteService = noteService;
     }
     // Este controlador se activar√≠a cuando en cliente visitase la url `notes/customer/{id}`,
     // donde `id` es una parte variable de la url. Por ejemplo, `notes/customer/5` devolver√≠a
     // todas las notas del cliente con ID = 5
     @GetMapping("/customer/{id}")
     public List<Note> getNotes(@PathVariable Long id) {
        return noteService.getNotesByCustomer(id);
     }
 }
 */
@Component
public class CustomerController {

    private final CustomerService customerService;
    public CustomerController(CustomerService customerService){
        this.customerService = customerService;

    }
    public void createCustomer(){
        String firstName, lastName;
        Scanner sc = new Scanner(System.in);

        System.out.println("Enter customer's first name:");
        firstName = sc.nextLine();
        System.out.println("Enter customer's last name:");
        lastName = sc.nextLine();
        this.customerService.createCustomer(firstName, lastName);
    }
}
```

Y lo usamos en el programa principal `JpaApplication`:

```java
......
private final CustomerController customerController;
public JpaApplication(CustomerRepository customerRepository,
                      NoteRepository noteRepository, CustomerController customerController){
    this.customerRepository = customerRepository;
    this.noteRepository = noteRepository;
    this.customerController = customerController;
}
.....
@Override
@Transactional
public void run(String... args) {
    this.customerController.createCustomer();
    this.customerRepository.findAll().forEach(System.out::println);
}
```

## Banco

Vamos a crear una relaci√≥n `n:m` , como la que vimos en un apartado anterior, entre `cliente` y `cuenta corriente`

```sql
CREATE TABLE clientes (
                          id INTEGER PRIMARY KEY AUTOINCREMENT,
                          nombre TEXT NOT NULL
);

CREATE TABLE cuentas_corrientes (
                                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                                    nombre TEXT NOT NULL,
    								 cantidad REAL
);

CREATE TABLE cliente_cuenta (
                                cliente_id INTEGER NOT NULL,
                                cuenta_id INTEGER NOT NULL,
                                PRIMARY KEY (cliente_id, cuenta_id),
                                FOREIGN KEY (cliente_id) REFERENCES clientes(id) ON DELETE CASCADE,
                                FOREIGN KEY (cuenta_id) REFERENCES cuentas_corrientes(id) ON DELETE CASCADE
);
```

Y `application.properties`

```properties
spring.datasource.url=jdbc:sqlite:banco.sqlite
spring.datasource.driver-class-name=
spring.jpa.database-platform=org.hibernate.community.dialect.SQLiteDialect
```

La entidad `Cliente`

```java
package org.ieselcaminas.jpa.entity;

import jakarta.persistence.*;

@Entity
// Se le puede indicar que el nombre de la tabla no es "cliente", nombre por defecto que es // igual al nombre la entidad (Cliente), sino "clientes"
@Table(name = "clientes")
public class Cliente {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false, length = 100)
    private String nombre;

    // Siempre un constructor por defecto
    public Cliente() {
    }
    public Cliente(String nombre) {
        this.nombre = nombre;
    }

    // Getters y Setters
    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getNombre() {
        return nombre;
    }

    public void setNombre(String nombre) {
        this.nombre = nombre;
    }

    @Override
    public String toString(){
        return this.nombre;
    }
}

```

Y la entidad `CuentaCorriente`

```java
package org.ieselcaminas.jpa.entity;

import jakarta.persistence.*;
import org.ieselcaminas.jpa.Cliente;
import java.util.HashSet;
import java.util.Set;

@Entity
// Se le puede indicar que el nombre de la tabla no es "cuenta_corriente", nombre por 
// defecto que es igual al nombre la entidad (CuentaCorriente), sino "cuentas_corrientes"
@Table(name = "cuentas_corrientes")
public class CuentaCorriente {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false, length = 100)
    private String nombre;

    @Column(nullable = false)
    private double cantidad;

    //Siempre debe tener un constructor vac√≠o
    public CuentaCorriente() {
    }

    //Se pueden hacer tantos constructores como deseemos
    public CuentaCorriente(String nombre) {
        this.nombre = nombre;
    }

    // Getters y Setters
    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    //Le decimos que, en la entidad Cliente, las cuentas se almacenan en el atributo con nombre cuentas
    @ManyToMany(mappedBy = "cuentas", fetch = FetchType.EAGER)
    //Hay que inicializar la lista siempre
    private Set<Cliente> clientes = new HashSet<>();

    public Set<Cliente> getClientes() {
        return this.clientes;
    }

    public void setClientes(Set<Cliente> clientes) {
        this.clientes = clientes;
    }

    // Se puede crear un m√©todo para a√±adir la entidad relacionada a la lista.
    // En otro caso, habr√≠a que usar cuenta.getClientes().add(cliente)
    public void addCliente(Cliente cliente){
        this.clientes.add(cliente);
    }
    public String getNombre() {
        return nombre;
    }

    public void setNombre(String nombre) {
        this.nombre = nombre;
    }

    public double getCantidad() {
        return cantidad;
    }

    public void setCantidad(double cantidad) {
        this.cantidad = cantidad;
    }

    // Otros setters
    public void ingresar(double cantidad){
        if (cantidad > 0 )
            this.cantidad += cantidad;
    }

    public void retirar(double cantidad){
        if (cantidad > 0 )
            this.cantidad -= cantidad;
    }

    @Override
    public String toString(){
        return this.nombre + " - " + this.cantidad;
    }
}
```

Y ahora ya podemos crear la relaci√≥n `n:m`:

En la entidad `Cliente`, a√±adimos la relaci√≥n :

```java
    /**
     * IMPORTANTE fetch = FetchType.EAGER. En caso contrario es FetchType.LAZY y da 
     * error porque no se inicializa la lista de cuentas
     */
    @ManyToMany(fetch = FetchType.EAGER)
    /*
       En este caso le decimos:
       - que la tabla se llama cliente_cuenta
       - que mi columna id se llama en esa tabla cliente_id
       - que la columna de la cuenta se llama cuenta_id en dicha tabla
     */
    @JoinTable(
            name = "cliente_cuenta",
            joinColumns = @JoinColumn(name = "cliente_id"),
            inverseJoinColumns = @JoinColumn(name = "cuenta_id")

    )
    // `cuentas` es el nombre que tiene el atributo `mappedBy` de
    // la relaci√≥n `ManyToMany` en `CuentaCorriente`
    // Inicializar siempre el Set
    private Set<CuentaCorriente> cuentas = new HashSet<>();

    public Set<CuentaCorriente> getCuentas() {
        return this.cuentas;
    }

    public void setCuentas(Set<CuentaCorriente> cuentas) {
        this.cuentas = cuentas;
    }

    // Se puede crear un m√©todo para a√±adir la entidad relacionada a la lista.
    // En otro caso, habr√≠a que usar cliente.getCuentas().add(cuenta)
    public void addCuenta(CuentaCorriente cuenta) {
        this.cuentas.add(cuenta);
    }
```

Y en la entidad `CuentaCorriente`

```java
    //Le decimos que, en la entidad Cliente, las cuentas se almacenan en el atributo con nombre cuentas
    @ManyToMany(mappedBy = "cuentas", fetch = FetchType.EAGER)
    //Hay que inicializar la lista siempre
    private Set<Cliente> clientes = new HashSet<>();

    public Set<Cliente> getClientes() {
        return this.clientes;
    }

    public void setClientes(Set<Cliente> clientes) {
        this.clientes = clientes;
    }

    // Se puede crear un m√©todo para a√±adir la entidad relacionada a la lista.
    // En otro caso, habr√≠a que usar cuenta.getClientes().add(cliente)
    public void addCliente(Cliente cliente){
        this.clientes.add(cliente);
    }
```

Los repositorios

```java
package org.ieselcaminas.jpa.repository;

import org.ieselcaminas.jpa.entity.Cliente;
import org.springframework.data.jpa.repository.JpaRepository;

public interface ClienteRepository extends JpaRepository<Cliente, Long> {}
```

y

```java
package org.ieselcaminas.jpa.repository;

import org.ieselcaminas.jpa.entity.CuentaCorriente;
import org.springframework.data.jpa.repository.JpaRepository;

public interface CuentaCorrienteRepository extends JpaRepository<CuentaCorriente, Long> {}
```

Y ahora ya podemos probarlo. 

Vamos a hacerlo mediante un `Servicio`. En un servicio vamos creando los m√©todos relacionados con una entidad y que no deban estar en el repositorio.

```java
package org.ieselcaminas.jpa.service;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

/**
 * Se pueden hacer tantos servicios como deseemos, pero siempre hemos de crear m√©todos relacionados
 * en ellos.
 */
@Service
public class ClienteService {
    /*
    La anotaci√≥n @Autowired indica a Spring que nos "auto inyecte" esta clase, en este caso ClienteRepository y
    CuentaCorrienteRepository.
    De esta forma ya no es necesario inyectarlas en el constructor
     */
    @Autowired
    private ClienteRepository clienteRepository;
    
    @Autowired
    private CuentaCorrienteRepository cuentaCorrienteRepository;

    public void crearClienteConCuenta(String nombreCliente, String nombreCuenta) {
        Cliente cliente = new Cliente(nombreCliente);
        CuentaCorriente cuenta = new CuentaCorriente();
        cuenta.setNombre(nombreCuenta);
        cuenta.addCliente(cliente);
        cliente.addCuenta(cuenta);
        this.clienteRepository.save(cliente);
        this.cuentaCorrienteRepository.save(cuenta);
    }
}
```

Y ahora en `main` lo probamos

```java
package org.ieselcaminas.jpa;

import org.ieselcaminas.jpa.service.ClienteService;
import org.springframework.boot.CommandLineRunner;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class JpaApplication implements CommandLineRunner {
    private final ClienteService clienteService;
    public JpaApplication(ClienteService clienteService) {
        this.clienteService = clienteService;
    }

    public static void main(String[] args) {
        SpringApplication.run(JpaApplication.class, args);
    }

    //En este m√©todo definimos nuestro propio c√≥digo
    @Override
	@Transactional
    public void run(String... args) {
        this.clienteService.crearClienteConCuenta("Mengano", "Cmengano");
    }
}
```

Vamos a crear otro m√©todo que permita asociar una cuenta con varios clientes:

```java
public void crearCuentaConClientes(String nombreCuenta) {
    CuentaCorriente cuenta = new CuentaCorriente();
    cuenta.setNombre(nombreCuenta);
    cuenta.setCantidad(100);

    Cliente cliente1 = new Cliente("Cliente 1");
    Cliente cliente2 = new Cliente("Cliente 2");

    cliente1.getCuentas().add(cuenta); // o cliente1.addCuenta(cuenta);
    cuenta.getClientes().add(cliente1); // o cuenta.addCliente(cliente);

    cliente2.getCuentas().add(cuenta);
    cuenta.getClientes().add(cliente2);

    this.cuentaCorrienteRepository.save(cuenta);
    this.clienteRepository.save(cliente1);
    this.clienteRepository.save(cliente2);
}
```

y en `main`

```java
@Override
@Transactional
public void run(String... args) { 
    this.clienteService.crearCuentaConClientes("CuentaConM√°sDeUnCliente");
}
```

Vamos a usar el asistente para creaci√≥n de relaciones que trae incorporado JPA Buddy, suponiendo que ya hab√©is creado las tablas.

1. Abre la entidad `Cliente`
   En la parte superior de la ventana aparece una barra de botones:
   ![image-20260225085504526](/programacion-java/assets/img/poo-tablas/image-20260225085504526.png)
   Haz clic en el tercero por la izquierda y elige la opci√≥n `Association`

   Ahora elige las opciones que se muestran a continuaci√≥n
   ![image-20260225085653912](/programacion-java/assets/img/poo-tablas/image-20260225085653912.png)
   Pulsa el bot√≥n `OK` . Aparecer√° otra ventana para las opciones del atributo inverso:
   ![image-20260225085837719](/programacion-java/assets/img/poo-tablas/image-20260225085837719.png)
   Vuelve a pulsar `OK`

Como resultado te debe haber generado el c√≥digo para las dos relaciones.

Tal vez quieras, hacer `addCuenta()` en `Cliente` y `addCliente` en cuentas

## Resumen

Los pasos para crear una aplicaci√≥n con Spring boot son:

* definir las dependencias en el archivo `pom.xml`
* crear las entidades donde se mapean los campos de la tabla con los atributos de la clase POJO
* crear los repositorios. Uno para cada entidad. Se puede ir definiendo los m√©todos conforme nos vayan haciendo falta.
* crear los controladores, donde crearemos m√©todos que usar√°n las entidades y los repositorios. 
* crear la aplicaci√≥n, seg√∫n el ejemplo.



## Creaci√≥n de una mini web.

Vamos a crear una web a partir de la bd de `Customer`. Va a ser muy sencilla: mostrar√° los nombres de los clientes y, a continuaci√≥n, la lista de los mensajes.

Primero, vamos a a√±adir las dependencias para desarrollar webs con Spring:

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
</dependency>
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-thymeleaf</artifactId>
</dependency>
```

Para ejecutar el servidor Web hay que lanzar el siguiente comando en la terminal `./mvnw spring-boot:run`

![image-20260225124141730](/programacion-java/assets/img/poo-tablas/image-20260225124141730.png)

Y arrancar√° el el puerto 8080, por defecto

![image-20260225124340610](/programacion-java/assets/img/poo-tablas/image-20260225124340610.png)

> -alert-Cada vez que modifiquemos algo del proyecto, hay que parar y volver a arrancar

Aparecer√° un mensaje de error, pero es normal, ya que no hemos creado todav√≠a ninguna ruta en un controlador.

![image-20260225130954399](/programacion-java/assets/img/poo-tablas/image-20260225130954399.png)

Y luego, elegimos `Controller`

![image-20260225131306282](/programacion-java/assets/img/poo-tablas/image-20260225131306282.png)

> -warning-Cuidado que hay que hacer p√∫blica la clase

En `CustomerController` creamos la siguiente ruta:

```java
package org.ieselcaminas.jpa.controller;

import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;

@Controller
@RequestMapping("/")
public class CustomerController {
    @GetMapping("/")
    public String inicio(Model model){
        return "index";
    }
}
```

* `@GetMapping("/")` le indica que este m√©todo se encarga de la ruta `/`, es decir, la ra√≠z de la web
* `index` es el nombre de la plantilla que va a mostrar. Usamos el motor de plantillas `Thymeleaf`

Ahora, creamos la plantilla `resources/templates/index.html` (el nombre de la plantilla debe coincidir con la cadena devuelta por el controlador, en este caso `index`) con el siguiente c√≥digo:

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<h1>Web de clientes</h1>
</body>
</html>
```

Reinicia el servidor y debe aparecer la siguiente ventana:

![image-20260225125650432](/programacion-java/assets/img/poo-tablas/image-20260225125650432.png)

Si es as√≠, es que todo ha ido bien.

### Listar clientes

Vamos a mostrar los clientes en la web. El proceso consta de las siguientes partes:

* Obtener los datos de todos los clientes

* Pas√°rselos a la plantilla `index`
* Hacer un `foreach` en la plantilla para recorrer todos los clientes.

Para obtener todos los clientes, usaremos el m√©todo `findAll` que ya est√° implementado en el repositorio

```java
package org.ieselcaminas.jpa.controller;

import org.ieselcaminas.jpa.repository.CustomerRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;

@Controller
@RequestMapping("/")
public class CustomerController {
    
    @Autowired // Que nos inyecte autom√°ticamente el repositorio
    private CustomerRepository customerRepository;

    @GetMapping("/")
    public String inicio(Model model){
        model.addAttribute("customers", customerRepository.findAll());
        return "index";
    }
}
```

El `Model` es la forma que tenemos para pasar datos a la plantilla html.

`model.addAttribute("customers", customerRepository.findAll());` indica que la variable `customers` va a estar disponible en la plantilla

Ahora vamos a pintarlos en la plantilla.

#### üßæ ¬øQu√© es una plantilla?

Es un archivo HTML que usa **Thymeleaf**, un motor de plantillas muy usado con **Spring Boot**.

üëâ Sirve para **mezclar HTML + datos Java** que vienen del servidor.

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<h1>Web de clientes</h1>
<ul>
    <li th:each="customer : ${customers}"
        th:text="${customer.firstName + ' ' + customer.lastName}">
        Cliente de ejemplo
    </li>
</ul>
</body>
</html> 	
```

#### üß± Estructura b√°sica

```html
<!DOCTYPE html>
<html lang="en">
```

Esto es HTML normal. Define el documento.

------

#### üìå T√≠tulo de la p√°gina

```html
<h1>Web de clientes</h1>
```

Texto fijo. No depende de Java.

------

#### üîÅ Bucle con Thymeleaf

```html
<ul>
    <li th:each="customer : ${customers}"
```

Aqu√≠ empieza lo interesante:

### üîπ `th:each`

Es como un `for` en Java.

üëâ Significa:

> "Para cada `customer` dentro de la lista `customers`"

------

### üîπ `${customers}`

Es una variable que viene del controlador Java:

```java
model.addAttribute("customers", lista);
```

üëâ Es decir:

- `customers` = lista de objetos `Customer`

------

#### üìÑ Mostrar datos

```
th:text="${customer.firstName + ' ' + customer.lastName}"
```

Esto hace:

üëâ Sustituye el contenido del `<li>` por:

```
Nombre Apellido
```

Ejemplo real:

```
Juan P√©rez
Ana Garc√≠a
```

------

### üîπ ¬øQu√© significa exactamente?

- `customer.firstName` ‚Üí nombre
- `customer.lastName` ‚Üí apellido
- `+ ' '` ‚Üí a√±ade un espacio

üëâ Es como en Java:

```java
customer.getFirstName() + " " + customer.getLastName()
```

#### üîÑ Resultado final en el navegador

Si tienes 3 clientes, el HTML generado ser√°:

```html
<ul>
    <li>Juan P√©rez</li>
    <li>Ana Garc√≠a</li>
    <li>Luis L√≥pez</li>
</ul>
```

------

#### ‚ö†Ô∏è Texto por defecto

```
Cliente de ejemplo
```

Esto sirve para:

üëâ Ver algo en el HTML si Thymeleaf no se ejecuta
üëâ Es reemplazado autom√°ticamente cuando la app corre

## Notas

Ahora vamos a mostrar las notas de los clientes.

```java
class Customer {
    String firstName;
    String lastName;
    List<Note> notes;
}
```

## üéØ Objetivo

Mostrar:

- Cliente (nombre + apellido)
- Debajo, su lista de notas

------

#### ‚úÖ Plantilla modificada

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Clientes</title>
</head>
<body>
<h1>Web de clientes</h1>
<ul>
    <li th:each="customer : ${customers}">
        <!-- Nombre del cliente -->
        <span th:text="${customer.firstName + ' ' + customer.lastName}"></span>
        <!-- Lista de notas -->
        <ul>
            <li th:each="note : ${customer.notes}"
                th:text="${note.text}">
                Nota de ejemplo
            </li>
        </ul>
    </li>
</ul>
</body>
</html>
```

------

#### üß† Explicaci√≥n

##### üîÅ Bucle exterior

```html
<li th:each="customer : ${customers}">
```

üëâ Recorre todos los clientes

------

##### üîÅ Bucle interior

```html
<li th:each="note : ${customer.notes}">
```

üëâ Para cada cliente, recorre sus notas

Esto es como en Java:

```java
for (Customer c : customers) {
    for (Note n : c.getNoteList()) {
        // mostrar nota
    }
}
```

##### üìÑ Ejemplo de resultado

```html
<ul>
  <li>
    Juan P√©rez
    <ul>
      <li>Llamar ma√±ana</li>
      <li>Enviar email</li>
    </ul>
  </li>
  <li>
    Ana Garc√≠a
    <ul>
      <li>Revisar contrato</li>
    </ul>
  </li>
</ul>
```